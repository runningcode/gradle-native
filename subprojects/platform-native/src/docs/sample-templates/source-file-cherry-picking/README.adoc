:language: c
:entry-point: application

:plugin-name: {language}-{entry-point}

ifeval::["{plugin-name}" == "c-application"]
:c-application: C application
:an-application: an application
:c: C
:source-file-extension: c
:header-file-extension: h
:application: application
endif::[]

ifeval::["{plugin-name}" == "cpp-application"]
:c-application: {cpp} application
:an-application: an application
:c: {cpp}
:source-file-extension: cpp
:header-file-extension: hpp
:application: application
endif::[]

ifeval::["{plugin-name}" == "objective-c-application"]
:c-application: Objective-C application
:an-application: an application
:c: Objective-C
:source-file-extension: m
:header-file-extension: h
:application: application
endif::[]

ifeval::["{plugin-name}" == "objective-cpp-application"]
:c-application: Objective-{cpp} application
:an-application: an application
:c: Objective-{cpp}
:source-file-extension: mm
:header-file-extension: hpp
:application: application
endif::[]

ifeval::["{plugin-name}" == "swift-application"]
:c-application: Swift application
:an-application: an application
:c: Swift
:source-file-extension: swift
:application: application
endif::[]

ifeval::["{plugin-name}" == "c-library"]
:c-application: C library
:an-application: a library
:c: C
:source-file-extension: c
:header-file-extension: h
:application: library
endif::[]

ifeval::["{plugin-name}" == "cpp-library"]
:c-application: {cpp} library
:an-application: a library
:c: {cpp}
:source-file-extension: cpp
:header-file-extension: hpp
:application: library
endif::[]

ifeval::["{plugin-name}" == "objective-c-library"]
:c-application: Objective-C library
:an-application: a library
:c: Objective-C
:source-file-extension: m
:header-file-extension: h
:application: library
endif::[]

ifeval::["{plugin-name}" == "objective-cpp-library"]
:c-application: Objective-{cpp} library
:an-application: a library
:c: Objective-{cpp}
:source-file-extension: mm
:header-file-extension: hpp
:application: library
endif::[]

ifeval::["{plugin-name}" == "swift-library"]
:c-application: Swift library
:an-application: a library
:c: Swift
:source-file-extension: swift
:application: library
endif::[]

:ref-plugin: <<plugin:{plugin-name}, {c-application} plugin>>

ifndef::c[ERROR: Please define `plugin-name` attribute.]

= {c-application} Custom Source File cherry-picking
:summary: Set custom source file cherry-picking for a {c-application}.
:type: sample-chapter
:tags: sample, {application}, sources, native, {C}, gradle
:category: {C}
:description: See how to set the source file cherry-picking of {an-application} implemented in {C} using the Gradle Nokee plugins.

NOTE: You can open this sample inside an IDE using the https://www.jetbrains.com/help/idea/gradle.html#gradle_import_project_start[IntelliJ native importer] or https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship].

Here is a sample where we set the source file cherry-picking {an-application} implemented in {C} with no dependencies and minimal configuration.

[source,groovy]
----
plugins {
	id 'dev.nokee.c-application'    // <1>
}

application {
    cSources.setFrom('srcs/main.c', 'srcs/potato/greeter.c') // <2>
    privateHeaders.setFrom(fileTree('incs') { include 'tomato/greeter.h' }) // <3>
    // See note regarding privateHeaders/publicHeaders
}

----
<1> Apply the {ref-plugin}.
<2> Set {application} sources from `srcs/main.c` and `srcs/potato/greeter.c` files
<3> Important to set private headers with the *include* pattern using *fileTree* to ensure the proper header search paths.
When a header file is picked by file path alone, the parent directory (enclosing directory) will be selected as one of the header search paths.
+
NOTE: Although users can cherry-pick header files by file path alone,
we recommend using a *fileTree* to cherry-pick the headers.
You can mix *cherry-picking*, *globing* and *generated* sources via appending.

Demonstration below where we see the {application} builds:

[source,terminal]
----
$ ./gradlew assemble

BUILD SUCCESSFUL
4 actionable tasks: 4 executed

----

